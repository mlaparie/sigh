#!/bin/bash
# Utility script to scrap data from rsoe-edis.org.
# Options allow generating/removing scrap scripts
# and showing/removing scraped data.
#
# Dependencies: jello, jtbl, fzf, less, sed
# 
# Author: Kabouik, inspired from aetin (see gemini://aetin.art/earth.gmi)

VERSION=0.3
WE_DIR="$(dirname "$(readlink -f "$0")")"

# Internal functions
has() {
    case "$(command -v "$1" 2>/dev/null)" in
        alias*|"") return 1
    esac
}

_phi() {
    >&2 printf '    %s\n' "$1"
}

_pht() {
    >&2 printf '%s\n' "$@"
}

_pemx() {
    >&2 printf '\033[31;1mError:\033[m %s\n' "$1"
    exit 1
}

version() {
    _pht "$(basename "$0") $VERSION"
    _pht "Working directory: '$WE_DIR'"
}

usage() {
    _pht "Scrap worldwide events from rsoe-edis.org"
    _pht
    _pht "Usage: $(basename "$0") [OPTION]"
    _pht
    _pht "'$(basename "$0")' depends on its directory structure, do not manually move the executable"
    _pht "to your PATH. './$(basename "$0") --setup' will offer to make a symbolic link in ~/.local/bin/."
    _pht
    _pht "  Options:"
    _phi "-g, --get [CODE]          Scrap data for event code to data/CODE.json."
    _phi "-p, --print [CODE]        Print saved data as json for event code."
    _phi "-t, --table [CODE]        Print saved data as table for event code."
    _phi "-l, --list-codes          List codes currently associated to scripts."
    _phi "-s, --setup               Create event scrap scripts and optionally link '$(basename "$0")' to PATH."
    _phi "-u, --update-codes        Fetch current event codes and save them."
    _phi "-R, --rm-scripts          Remove existing script(s) and optionally remove '$(basename "$0")' from PATH."
    _phi "-C, --clear-data ([CODE]) Remove queried data or all data files (clean data/ directory)."
    _phi "-v, --version             Print version."
    _phi "-h, --help                Print this help."
    _pht
    _pht "  Improve me:"
    _phi "https://git.teknik.io/matf/worldevents"
}

# Main functions
setup() {
    # Generate individual .py files for each "subList" code from rsoe.edis.org.
    # To get all subList codes, go to rsoe-edis.org/eventList, edit page source,
    # and find each "subList-" occurrence, they are followed by available codes.
    # Save codes in cats.txt, with one code per line.
    # Can be done easily with kakoune and `%ssubList-w<ret>y%<a-d><a-p>`.
    mkdir -p "$WE_DIR"/scripts
    cd "$WE_DIR" || exit
    while read -r code;
        do sed "s/replaceme/$code/g" "$WE_DIR"/setup/template.py > "$WE_DIR/scripts/$code.py";
        chmod +x "$WE_DIR/scripts/$code.py";
    done < "$WE_DIR"/setup/codes.txt
    printf "Generating scrap scripts for the following codes…\n"
    listcodes
    printf "\n$(find "${WE_DIR}"/scripts/*.py -maxdepth 1 -type f 2>/dev/null | wc -l) scrap scripts created in ${WE_DIR}/scripts/. \033[32;1m%s\033[0m\n" '✔'
    
    # Check if $(basename "$0") already in PATH, else create symlink into ~/.local/bin/
    ! has we && in_path="false"
    if [ "$in_path" == "false" ]; then
       printf "\n'%s' is not in your PATH. Create symlink into ~/.local/bin/ to access the command from anywhere? [Y/n] " "$(basename "$0")" && read -r
       if ! [ "$REPLY" = "n" ] || [ "$REPLY" = "N" ] || \
           [ "$REPLY" = "no" ] || [ "$REPLY" = "NO" ]; then
           ln -s "$WE_DIR"/we "$HOME"/.local/bin/we
           printf "Done. You can now run '$(basename "$0")' from anywhere. \033[32;1m%s\033[0m\n" '✔'
       fi
    fi
}

get() {
    export WE_DIR
    if [ -z "$1" ]; then
        cod="$(fzf < "$WE_DIR"/setup/codes.txt)"
        python3 "$WE_DIR"/scripts/"$cod".py 2>/dev/null
        if ! [ -f "${WE_DIR}/scripts/${cod}.py" ]; then
            printf '\033[31;1mErr:\033[0m %s\n' "there is no scrap script for $cod yet, please run '$(basename "$0") -s' first and make sure this code is available in '$(basename "$0") -l'."
        fi
    else
        mkdir -p "$WE_DIR"/data
        cod=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        python3 "$WE_DIR"/scripts/"$cod".py 2>/dev/null
        if ! [ -f "${WE_DIR}/scripts/${cod}.py" ]; then
            printf '\033[31;1mErr:\033[0m %s\n' "there is no scrap script for $cod yet, please run '$(basename "$0") -s' first and make sure this code is available in '$(basename "$0") -l'."
        fi
    fi
}

print() {
    if [ -z "$1" ]; then
        cod="$(fzf < "$WE_DIR"/setup/codes.txt)"
        jello < "$WE_DIR"/data/"$cod".json
    else
        cod=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        jello < "$WE_DIR"/data/"$cod".json
    fi
}

table() {
    print "$1" | jtbl -n | less -S
}

listcodes() {
     tr '\n' '\t' < "$WE_DIR"/setup/codes.txt | fold -w 80 -s
}

getcodes() {
    printf "Fetching codes is not implemented yet, sadly. :<"
}

rmscripts() {
    printf '\033[33;1mWrn:\033[0m %s' "remove $(find "${WE_DIR}"/scripts/*.py -maxdepth 1 -type f 2>/dev/null | wc -l) scrap scripts? [y/N] " && read -r
    if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ] || \
        [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
        rm "$WE_DIR"/scripts/*.py 2>/dev/null
        printf "${WE_DIR}/scripts/ directory cleaned. \033[32;1m%s\033[0m\n" '✔'
        printf "Run '%s' to regenerate scrap scripts.\n" "$(basename "$0") -s"
    fi

    # Check if $(basename "$0") already in PATH, else create symlink into ~/.local/bin/
    has we && in_path="true"
    if [ "$in_path" == "true" ]; then
       printf "\nAlso remove '%s' symbolic link from your PATH? [y/N] " "$(basename "$0")" && read -r
       if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ] || \
           [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
           rm "$HOME"/.local/bin/we
           printf "Done. \033[32;1m%s\033[0m\n" '✔'
       fi
    fi
}

cleardata() {
    if [ -z "$1" ]; then
        printf '\033[33;1mWrn:\033[0m %s' "delete $(find "${WE_DIR}"/data/*json -maxdepth 1 -type f 2>/dev/null | wc -l) previously scraped data file(s)? This cannot be undone. Type YES to confirm. " && read -r
        if [ "$REPLY" = "YES" ]; then
           rm "$WE_DIR"/data/*.json
           printf "${WE_DIR}/data/ directory cleaned. \033[32;1m%s\033[0m\n" '✔'
        fi
    else
        cod=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        if ! [ -f "${WE_DIR}/data/${cod}.json" ]; then
            printf '\033[31;1mErr:\033[0m %s\n' "$cod.json was not scraped yet."
        else
            printf '\033[33;1mWrn:\033[0m %s' "delete $cod.json? This cannot be undone. [y/N] " && read -r
            if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ] || \
                [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
               rm "$WE_DIR"/data/"$cod".json
               printf "${WE_DIR}/data/$cod.json removed. \033[32;1m%s\033[0m\n" '✔'
            fi
        fi
    fi
}

interactive() {
    usage ; exit 0
#    arg="$(fzf < $(printf "get\nprint\ntable\nlistcodes\nsetup\nupdatecodes\nrm-scripts\nclear-data\nversion\nhelp"))"
#    we $arg
}

# Dependency check
for prog in jello jtbl sed less fzf; do
     ! has "$prog" && dependencies_not_installed="${dependencies_not_installed}${prog}, "
done

[ -n "${dependencies_not_installed}" ] && _pemx "missing dependencies, please install: ${dependencies_not_installed%??}."

# Options
if [ -z "$1" ]; then
    interactive ;
fi

    case "$1" in
    "-g"|"--get")
        get "$2" "$WE_DIR" ; exit ;;
    "-p"|"--print")
        print "$2" "$WE_DIR" ; exit ;;
    "-t"|"--table")
        table "$2" "$WE_DIR" ; exit ;;
    "-l"|"--list-codes")
        listcodes "$WE_DIR" ; exit ;;
    "-s"|"--setup")
        setup "$WE_DIR" ; exit ;;
    "-u"|"--update-codes")
        updatecodes "$WE_DIR" ; exit ;;
    "-R"|"--rm-scripts")
        rmscripts "$WE_DIR" ; exit ;;
    "-C"|"--clear-data")
        cleardata "$2" "$WE_DIR" ; exit ;;
    "-i"|"--interactive")
        interactive "$2" "$WE_DIR" ; exit ;;
    "-v"|"--version")
        version "$WE_DIR" ; exit 0 ;;
    "-h"|"--help")
        usage ; exit 0 ;;
    -*)
        _pemx "$1 is not a supported option." ;;
    *)
        usage ; exit 0 ;;
esac

#!/bin/bash
# Utility script to scrap data from rsoe-edis.org.
# Options allow generating/removing scrap scripts
# and showing/removing scraped data.
#
# Dependencies: python3, fzf, jq, jtbl, sed, less
# 
# Author: Kabouik, inspired from aetin (see gemini://aetin.art/earth.gmi)

VERSION=0.3
WE_DIR="$(dirname "$(readlink -f "$0")")"
FZFOPTS=( --height=100% --layout=reverse --cycle --border --marker='*' )

# Internal functions
has() {
    case "$(command -v "$1" 2>/dev/null)" in
        alias*|"") return 1
    esac
}

_phi() {
    >&2 printf '    %s\n' "$1"
}

_pht() {
    >&2 printf '%s\n' "$@"
}

_pemx() {
    >&2 printf '\033[31;1mError:\033[m %s\n' "$1"
    exit 1
}

findcmd() {
    find . -type f -printf '%f\n' | sort
}

fzfcmd() {
    fzf --ansi \
        --header=$'Ret  print & exit
C-e  edit
C-x  edit beautified
     dep: kakoune
C-v  view table/json
C-r  ripgrep
     dep: rga-fzf
?    toggle preview\n\n' \
        --preview="$1" \
        --preview-window="right:80%:wrap:cycle" --delimiter / --with-nth -1 \
        --bind="?:toggle-preview" \
        --bind="ctrl-r:execute(rga-fzf {} '')" \
        --bind="ctrl-e:execute(${EDITOR:-vim --not-a-term} {} </dev/tty)" \
        --bind="ctrl-x:execute(kak -e 'execute-keys <%><|>jq<ret><g><e>' {} </dev/tty)" \
        --bind="$2" \
        --bind="$3" \
        "${FZFOPTS[@]}" \
        "$4"
}
 
version() {
    # Print version and working directory
    _pht "$(basename "$0") $VERSION"
    _pht "Working directory: '$WE_DIR'"
}

quit() {
    exit 0
}

show-help() {
    # Show help
    _pht "Scrap worldwide events from rsoe-edis.org"
    _pht
    _pht "Usage: $(basename "$0") [OPTION]"
    _pht
    _pht "'$(basename "$0")' depends on its directory structure, do not manually move the executable"
    _pht "to your PATH. './$(basename "$0") --setup' will offer to make a symbolic link in ~/.local/bin/."
    _pht
    _pht "  Options:"
    _phi "-g, --get [CODE]          Scrap data for event code to data/CODE.json."
    _phi "-p, --print [CODE]        Print saved data as json for event code."
    _phi "-t, --table [CODE]        Print saved data as table for event code."
    _phi "-l, --list-codes          List codes currently available to generate scripts."
    _phi "-s, --setup               Create event scrap scripts and optionally link '$(basename "$0")' to PATH."
    _phi "-u, --update-codes        Fetch current event codes and save them."
    _phi "-R, --rm-scripts          Remove existing script(s) and optionally remove '$(basename "$0")' from PATH."
    _phi "-C, --clear-data ([CODE]) Remove queried data or all data files (clean data/ directory)."
    _phi "-v, --version             Print version and path to working directory."
    _phi "-h, --help                Print this help."
    _pht
    _pht "  Improve me:"
    _phi "https://git.teknik.io/matf/worldevents"
}

# Main functions
setup() {
    # Generate individual .py files for each "subList" code from rsoe.edis.org.
    # To get all subList codes, go to rsoe-edis.org/eventList, edit page source,
    # and find each "subList-" occurrence, they are followed by available codes.
    # Save codes in cats.txt, with one code per line.
    # Can be done easily with kakoune and `%ssubList-w<ret>y%<a-d><a-p>`.
    mkdir -p "$WE_DIR"/scripts
    cd "$WE_DIR"/scripts || exit
    while read -r code;
        do sed "s/replaceme/$code/g" "$WE_DIR"/setup/template.py > "$code.py";
        chmod +x "$code.py";
    done < "$WE_DIR"/setup/codes.txt
    printf "Generating scrap scripts for the following codes…\n"
    list-codes
    printf "$(findcmd | wc -l) scrap scripts created in ${WE_DIR}/scripts/. \033[32;1m%s\033[0m\n" '✔'
    
    # Check if $(basename "$0") already in PATH, else create symlink into ~/.local/bin/
    ! has sigh && in_path="false"
    if [ "$in_path" == "false" ]; then
       printf "\n'%s' is not in your PATH. Create symlink into ~/.local/bin/ to access the command from anywhere? [Y/n] " "$(basename "$0")" && read -r
       if ! [ "$REPLY" = "n" ] || [ "$REPLY" = "N" ] || \
           [ "$REPLY" = "no" ] || [ "$REPLY" = "NO" ]; then
           ln -s "$WE_DIR"/sigh "$HOME"/.local/bin/sigh
           printf "Done. \033[32;1m%s\033[0m You can now run '$(basename "$0")' from anywhere.\n" '✔'
       fi
    fi
}

get() {
    # Scrap data, use fzf if no code provided
    export WE_DIR
    cd "$WE_DIR"/setup 2>/dev/null || exitonerror "no scrap scripts generated yet. Run '$(basename "$0") -s first.'"
    mkdir -p "$WE_DIR"/data
    if [ -z "$1" ]; then
        nscripts="$(findcmd | wc -l)"
        if [ "$nscripts" -eq "0" ]; then
            exitonerror "no scrap scripts generated yet. Run '$(basename "$0") -s' first."
        else
            cod=( $(cat subcategories.txt | \
                fzf "${FZFOPTS[@]}" --multi --header=$'Pick event type(s):\nTab  multi-selection\n\n' | xargs) )
            for i in "${cod[@]}"
                do printf 'Scraping ' && python3 getevents.py -s "$i"
            done
            quit
        fi
    else
        cod=( $(echo "$@" | tr '[:lower:]' '[:upper:]' | xargs) )         
        unset 'cod[0]' ; unset 'cod[-1]'
        if [ "${#cod[@]}" -eq "0" ]; then
            get
        fi
        for i in "${cod[@]}"
            do printf 'Scraping '
            python3 getevents.py -s "$i" 2>/dev/null
            if ! [ -f "$i.py" ]; then
                printf ' \033[31;1mErr:\033[0m %s\n' "no scrap script for $i yet. Make sure this code is available in '$(basename "$0") -l' and regenerate scripts with '$(basename "$0") -s'."
            fi
        done
    fi
}

print() {
    # Show scraped data, use fzf if no code provided
    cd "$WE_DIR"/data 2>/dev/null || exitonerror "no data scraped yet. Run '$(basename "$0") -g first.'"
    if [ -z "$1" ]; then
        ndata="$(findcmd | wc -l)"
        if [ "$ndata" -eq "0" ]; then
            exitonerror "no data scraped yet. Run '$(basename "$0") -g' first."
        else
            cod=( $(findcmd | \
            fzfcmd "cat {} | jq" "ctrl-p:execute(cat {} | jq)+abort" "ctrl-v:execute(cat {} | jq | jtbl -n | less -SN)" "--multi" < /dev/tty > /dev/tty) )
            for i in "${cod[@]}"
                do printf '\n%s\n--------\n' "$i"
                jq < "$i"
            done
            quit
#        fzfcmd "cat {} | jq" "enter:execute(cat {} | jq)+abort" "ctrl-v:execute(cat {} | jq | jtbl -t | less -S)"
#--multi --header=$'Pick event type(s):\nTab  multi-selection\n\n' | xargs) )
        fi
    else
        cod=( $(echo "$@" | tr '[:lower:]' '[:upper:]' | xargs) )
        unset 'cod[0]' ; unset 'cod[-1]'
        if [ "${#cod[@]}" -eq "0" ]; then
            print
        fi
        for i in "${cod[@]}"
            do printf '\n%s\n--------\n' "$i.json"
            cat "$i".json 2>/dev/null | jq
            if ! [ -f "$i.json" ]; then
                printf ' \033[31;1mErr:\033[0m %s\n' "no data scraped for $i yet. Run '$(basename "$0") -g $i' first."
            fi
        done
    fi
}

table() {
    # Show scraped data as table, use fzf if no code provided
    cd "$WE_DIR"/data 2>/dev/null || exitonerror "no data scraped yet. Run '$(basename "$0") -g first.'"
    if [ -z "$1" ]; then
        ndata="$(findcmd | wc -l)"
        if [ "$ndata" -eq "0" ]; then
            exitonerror "no data scraped yet. Run '$(basename "$0") --get' first."
        else
        findcmd | \
            fzfcmd "cat {} | jq | jtbl -t" "ctrl-p:execute(cat {} | jq | jtbl -t)+abort" "ctrl-v:execute(cat {} | jq | less -SN)" "--multi"
        fi
    else
        cod=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        jq < "$WE_DIR"/data/"$cod".json | jtbl -t
    fi
}

list-codes() {
    # List available codes
    tr '\n' '\t' < "$WE_DIR"/setup/codes.txt | fold -w 80 -s
    printf "\n"
}

update-codes() {
    export WE_DIR
    printf 'Fetching current categories… '
    python3 "$WE_DIR"/setup/getnewsubcategories.py
}

exitonerror() {
    printf '\033[31;1mErr:\033[0m %s\n %s' "$1" && exit
}

rm-scripts() {
    # Remove scrap scripts
    cd "$WE_DIR"/scripts 2>/dev/null || exitonerror "no scrap scripts generated yet. Run '$(basename "$0") -s first.'"
    if [ -z "$1" ]; then
        nscripts="$(findcmd | wc -l)"
        if [ "$nscripts" -eq "0" ]; then
           exitonerror "no scrap scripts to delete."
        else
            printf '\033[33;1mWrn:\033[0m %s' "[r]emove $(findcmd 2>/dev/null | wc -l) scrap scripts, [c]herry pick, or [a]bort? " && read -r
            if [ "$REPLY" = "a" ] || [ "$REPLY" = "A" ] || [ "$REPLY" = "" ]; then
                quit
            elif [ "$REPLY" = "r" ] || [ "$REPLY" = "R" ]; then
                # printf 'This cannot be undone. Type YES to confirm. ' && read -r
                # if [ "$REPLY" = "y" ] || [ "$REPLY" = "y" ] || \
                #     [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
                rm *.py 2>/dev/null
                printf "${WE_DIR}/scripts/ directory cleaned. \033[32;1m%s\033[0m\n" '✔'
                # Check if $(basename "$0") already in PATH, else create symlink into ~/.local/bin/
                has sigh && in_path="true"
                if [ "$in_path" == "true" ]; then
                   printf "\nAlso remove '%s' symbolic link from your PATH? [y/N] " "$(basename "$0")" && read -r
                   if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ] || \
                       [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
                       rm "$HOME"/.local/bin/sigh
                       printf "Done. \033[32;1m%s\033[0m\n" '✔'
                   fi
                fi
            elif [ "$REPLY" = "c" ] || [ "$REPLY" = "C" ]; then
                cod=( $(findcmd | sed s/.py// | \
                    fzf "${FZFOPTS[@]}" --multi --header=$'Pick event type(s):\nTab  multi-selection\n\n' | xargs) )
                for i in "${cod[@]}"
                    do rm "$i.py"
                done
                printf 'Removed %s scripts. \033[32;1m✔\033[0m\n' "${#cod[@]}"
                quit
            fi 
        fi
    else
        cod=( $(echo "$@" | tr '[:losighr:]' '[:upper:]' | xargs) )
        unset 'cod[0]' ; unset 'cod[-1]'
        if [ "${#cod[@]}" -eq "0" ]; then
            rm-scripts
            quit
        fi
        printf '\033[33;1mWrn:\033[0m %s' "remove ${#cod[@]} scrap scripts? [Y/n] " && read -r
        if [ "$REPLY" = "n" ] || [ "$REPLY" = "N" ] || [ "$REPLY" = "no" ] || [ "$REPLY" = "NO" ]; then
            quit
        else
            # printf 'This cannot be undone. Type YES to confirm. ' && read -r
            # if [ "$REPLY" = "y" ] || [ "$REPLY" = "y" ] || \
            #     [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
            for i in "${cod[@]}"; do
                if ! [ -f "$i.py" ]; then
                    printf ' \033[31;1mErr:\033[0m %s\n' "no $i script to delete."
                else
                    rm $i.py 2>/dev/null
                    printf 'Removed %s.py \033[32;1m✔\033[0m\n' "$WE_DIR/scripts/$i"
                fi
            done
            quit
        fi
    fi
}

clear-data() {
    # Remove data
    cd "$WE_DIR"/data 2>/dev/null || exitonerror "no data scraped yet. Run '$(basename "$0") -g first.'"
    if [ -z "$1" ]; then
        printf '\033[33;1mWrn:\033[0m %s' "delete $(findcmd 2>/dev/null | wc -l) previously scraped data file(s)? This cannot be undone. Type YES to confirm. " && read -r
        if [ "$REPLY" = "YES" ]; then
           rm "$WE_DIR"/data/*.json
           printf "${WE_DIR}/data/ directory cleaned. \033[32;1m%s\033[0m\n" '✔'
        fi
    else
        cod=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        if ! [ -f "${cod}.json" ]; then
            printf '\033[31;1mErr:\033[0m %s\n' "$cod.json was not scraped yet."
        else
            printf '\033[33;1mWrn:\033[0m %s' "delete $cod.json? This cannot be undone. [y/N] " && read -r
            if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ] || \
                [ "$REPLY" = "yes" ] || [ "$REPLY" = "YES" ]; then
               rm "$cod".json
               printf "${WE_DIR}/data/$cod.json removed. \033[32;1m%s\033[0m\n" '✔'
            fi
        fi
    fi
}

interactive() {
    # Use fzf to manipulate program options
    cmd=$(echo "get print table list-codes setup update-codes rm-scripts clear-data version show-help quit" \
    | tr ' ' '\n' | fzf "${FZFOPTS[@]}")
    eval $cmd
}

# Dependency check
for prog in python3 fzf jello jtbl sed less; do
     ! has "$prog" && dependencies_not_installed="${dependencies_not_installed}${prog}, "
done

[ -n "${dependencies_not_installed}" ] && _pemx "missing dependencies, please install: ${dependencies_not_installed%??}."

# Options
if [ -z "$1" ]; then
    interactive ;
fi

    case "$1" in
    "-g"|"--get")
        get "$@" "$WE_DIR" ; exit ;;
    "-p"|"--print")
        print "$@" "$WE_DIR" ; exit ;;
    "-t"|"--table")
        table "$2" "$WE_DIR" ; exit ;;
    "-l"|"--list-codes")
        list-codes "$WE_DIR" ; exit ;;
    "-s"|"--setup")
        setup "$WE_DIR" ; exit ;;
    "-u"|"--update-codes")
        update-codes "$WE_DIR" ; exit ;;
    "-R"|"--rm-scripts")
        rm-scripts "$@" "$WE_DIR" ; exit ;;
    "-C"|"--clear-data")
        clear-data "$2" "$WE_DIR" ; exit ;;
    "-i"|"--interactive")
        interactive "$WE_DIR" ; exit ;;
    "-v"|"--version")
        version "$WE_DIR" ; exit 0 ;;
    "-h"|"--help")
        show-help ; exit 0 ;;
    -*)
        _pemx "$1 is not a supported option." ;;
    *)
        quit ;;
esac
